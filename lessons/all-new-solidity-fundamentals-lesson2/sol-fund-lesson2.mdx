## Solidity Fundamental Side Drawers for Lesson 2

### import

    The idea of importing files in Solidity is very similar to the concept of modules.
    A modulus is a chunk or block of code. The idea behind modules is to break code into reusable components.
    You group functionalities in a module file and expose them to other files so that these other files can use them.
    
    It helps modularise your smart contracts by:
- Creating reusable pieces that other files can import.
- Making it easier to understand and digest the entire Solidity codebase of your project.
- Making it easier to work with the *“Solidity modules”* by focusing on smaller files (useful when debugging).
You can import local and external files in Solidity.




### constructor 
    A constructor is an optional function that is executed upon contract creation.

    With Solidity, the code defined inside the constructor will run only once, at the time the contract is created and deployed in the network.
    
Also we can add the keyword `immutable` in variable that will get value from constructor.
```
string public immutable name;
```
To make our code more gas efficient




### msg.sender 
    Every smart contract invocation has a caller address. 
    Each EVM (Ethereum Virtual Machine that executes the code) knows which account carries out each action. 
    In Solidity, you can access the calling account by referencing `msg.sender`

So when you call a function of solidity contract, your contract already gets the information of your account, so your account is the `msg.sender`
    






### mint function
Let's take the [open-zeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol) implementation  of ERC721:

**_mint() function**
```
 /**
   * @dev Internal function to mint a new token
   * Reverts if the given token ID already exists
   * @param to The address that will own the minted token
   * @param tokenId uint256 ID of the token to be minted by the msg.sender
   */
  function _mint(address to, uint256 tokenId) internal {
    require(to != address(0));
    _addTokenTo(to, tokenId);
    emit Transfer(address(0), to, tokenId);
}
```
Here it checks that the `to` address isnt the `0x0` address (empty address/default address), and then calls the `_addTokenTo` function.

**_addTokenTo() function**
```
/**
   * @dev Internal function to add a token ID to the list of a given address
   * @param to address representing the new owner of the given token ID
   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address
   */
  function _addTokenTo(address to, uint256 tokenId) internal {
    require(_tokenOwner[tokenId] == address(0));
    _tokenOwner[tokenId] = to;
    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);
}
```
Here it checks that a token with the same token ID is not already owned by someone else (by checking that it is owned by the `0x0` address, which is default).
If no one owns that token ID, then it sets the owner of that token ID to the to address, and increases the count of owned tokens for that to address.

Ultimately these are the steps required to create a new token and assign that token an owner.





### base URI function
    Base URI is used for computing {tokenURI}. The TokenURI is a link pointing to the Metadata for a single token. 
    Metadata is the data or information of the NFT such as Name, description, stats and so on, Your imagination is your only limit.
    
    If set, the resulting URI for each token will be the concatenation of the `baseURI` and the `tokenId`. 
    Empty by default, can be overridden in child contracts.






### override
    Solidity supports multiple inheritance. Contracts can inherit other contract by using the `is` keyword. 
    Solidity inheritance lets us combine multiple contracts into a single one. The base contracts are the ones from which other inherit. 
    Those contracts that inherit data are derived. This is a process resulting in parent-child relationships between contracts.
    There are two types of inheritance:
    single and multi-level
    
    To use inheritance we have use `override` and `virtual`
    
    Function that is going to be overridden by a child contract must be declared as `virtual`.
    Function that is going to override a parent function must use the keyword `override`.
    Order of inheritance is important.
    You have to list the parent contracts in the order from “most base-like” to “most derived”.
