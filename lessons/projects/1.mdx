---
i18n: "smart-contracts"
title: Getting Started with Smart Contract Development
description: Learn Basics of Smart Contract Development and Remix.
icons: ["solidity", "remix"]
---

# Lesson 1: Intro to Smart Contract Development

## What are we building?

### Where are we going with it? Web what? Smart contract?

We’re going to build a **smart contract**, but what on Jupiter is a smart contract? And what on Earth would we use one for? Well, you wouldn’t find a smart contract on either Jupiter, or Earth, and although you maybe grounded to the latter, you are going to deploy yours on a **blockchain**. Not a real blockchain, well not at first. Hang on!

<ContentSideDrawer title="A what chain?!!">
A blockchain has quite a few layers to let function, but it basically gives us a place to do computation, and store information. So in one sense it functions as a database. Think about this. To get access to all of the information on a traditional database you need permission from a higher authority, right? Access to information on a public blockchain is permission**less**. Not only can we read the information on it, but anyone can also write information to it. And that’s where we come in and get this all started with our *smart contract*. And what is also different to a traditional database is that once the information goes onto this blockchain, it stays there forever, and ever, and ever….thanks to cryptography!!

But what is the information that is kept on this chain? Wait. Why a chain? Well basically transactions, often, but not always, financial, are made and recorded and bundled into blocks of a limited capacity and they keep getting added on to make a continuing *block chain*. Each transaction contains quite a limited amount of information, but gives us transparency so that anyone can trace the *money trail*. And this was one of the main intentions of blockchains. Transparency. There are ever growing use cases for the types of transactions, financial and non-financial. Let’s move on. The blocks are secured to each other with cryptography. A similar type of encryption that is used to secure the Signal or Telegram apps on your smartphone…..(any other examples???) If someone did try to change any information on the chain, the alarm bells would go off. 

So how is all this permission**lessness** possible? Can’t someone shut this blockchain down? Simply put, no. A public blockchain actually runs on a network of computers, which can be distributed all around the world. We call each of these computers a node when they run a programme called ‘client’ software, which lets the whole network communicate… and nobody is in charge. Some blockchains have tens of thousands of nodes across dozens of countries. 

To maintain, or run a node and the software, you need to be slightly technically minded, and there are a couple of other requirements and considerations which we’ll discuss in later lessons, but what is important to appreciate, is that the people running their computers as nodes on the network for the most part don’t know each other. So thanks to this decentralized reality, the nodes can’t collaborate with each other in great enough numbers to form a 51% group and take over the whole network, so there is no higher authority.

So we have what is like a global computer which is permissionless, transparent and distributed, and as long as 66% of the nodes are running, the blockchain can keep on going quite safely, which makes it almost completely censorship resistant. Think about that for a second.  And it gets better…..

Really? What’s so special about all of this? Well until recently, we only transferred data on the internet. Yes, you could send money too by using some kind of banking app, or financial services app like Western Union, but with the advent of crypto currencies we can now send *digital* value… permissionlessly. That's quite a thing! In the early days of crypto we could only transact with digital tokens such as BTC and then ETH and soon later, with thousands of different coins. But new ideas continue to emerge and we’re going to be building a few of them!!!

The distributed sharing of value on blockchain has opened up further development of networks that for example facilitates the distribution of storage, where, like running a blockchain node, people can use their home computer’s storage device for storing other people’s data, and earn a bit of money in return. That’s where your NFTs (will) live!! Many, many more internet services, or protocols that have been centralized until now have emerged to complement and add extra functionality to all of the above, and many completely new protocols are being added really quickly! So you are going to hear words like composability, interoperability, money-legos, etc. We are also finally getting to a stage of internet evolution where we can own our personal data again and be able to transfer value without worrying about a middleman saying if we can or can’t.

This is what we call Web3. Welcome!!

So back to the smart contract. What the hell is it? It’s a piece of computer code that will do whatever we programme it to do. And once we have written and rigorously tested the code, we *deploy* it to the blockchain, once and for all, where it will live there happily ever after. Unless we mess up something when writing the code, where it will live there very, very unhappily ever after. With lots of very unhappy people. Unlike your smartphone apps, or your operating system that can have updates once in a while, you can’t just decide to rewrite a smart contract, or update it, unless you actually create it with that functionality, but quite often there are good reasons why you won’t want to. So when we write a contract, we have to be smart too! The most common use for a smart contract is to store or transfer value and the last thing we want is them to be compromised in any way. So let’s get used to the idea of test, test, testing them. 

Last but not least, the end user. The user accesses the blockchain through a user interface that we call a wallet address, because it lets us interact with crypto tokens and sign the smart contracts we interact with. Any address on the blockchain looks something like this: 0x450904F9c3eab65812963d17790ca2615555fD64. These addresses are an integral means of communication on and with any blockchain. Not only does a user have an address like this, but all the smart contracts on the blockchain have one as well, and use them as a means of communication too. Like phone numbers, or emails blockchain style! It’s becoming more common that a user will have an easier to remember alias for their address e.g. [imsoeasy.](http://imsoeasy.xyz)eth!

</ContentSideDrawer>
<br/>
<ContentSideDrawer title="A bit more info on smart contracts...">

A smart contract, as it suggests is a contract, but written into computer code and stored and executed on a blockchain. What does it let us do? In simple terms, it allows two parties to buy and sell something and confirm their signatures to close  the sale. Until now, buying and selling of crypto tokens, and more recently NFTs, have seen most of the ‘on-chain’ activity and news coverage, but there is much, much more and the use cases for them on and off-chain is growing at an exponential rate, therefore the development of them couldn’t be more exciting.
Humans have been buying, selling and signing contracts for millennia, what is new here?
We don’t need a third party, central authority or any kind of legal system to verify the transaction. The contract is in the code, the users sign it and the contract ‘smartly’ self-executes, in other words permissionlessly. Because the blockchains that we are learning about are heavily decentralised, it makes this all possible. And there are many more benefits to this decentralised model as we’ll continue to see.

</ContentSideDrawer>

## Let’s get this party started!

We’re going to write a smart contract, which is going to be a “Web3 fortune-teller". The idea is that you will input a message into the contract, the contract will decode the message, and like a fortune-teller would do, predict your future… in Web3.

Before we start, we need a place to write our Solidity language smart contract, and some tools to run it. For that we use the Remix IDE, short for...

<ContentSideDrawer title="Integrated Development Environment">

So what is actually integrated into this environment of Remix and what do we need it for?
For a start, it’s a tool in your browser which emulates a blockchain stack. Since it has a lot of the features needed to run a smart contract, it let’s us get started with learning how to develop one and see how it would work on a live network and also some of the things a user would experience on a front end application. Experienced developers still use it too because it is so handy for a lot of things. It’s a pretty nifty tool!!
It has:

A `file explorer`: a place to write and store your smart contracts and files of code as you work with them online.

A `compiler`: for your Solidity code, which will let you know if your contract code is bug free, and then compile it for you. Compiling is basically translating it into another programming language that the blockchain can work with.

A `batch of 10 wallet addresses` which you can use and interact with while you work.

A `deployer`, which places the contract on the emulated blockchain after it’s compiled and lets you play around with its functions and learn about them and their outputs.

A `‘terminal’` window where you can read all the output and logs from each time you interact with the contract. This is what you would expect to see on a working blockchain validator’s node.

There are a lot more features in Remix, but those are the ones we’ll be working with.

</ContentSideDrawer>

## Setting up Remix (IDE)

To get started we will use the Remix IDE to write, compile, test and debug code quickly and easily. Head over to [https://remix.ethereum.org/](https://remix.ethereum.org/) to see what it’s all about and get started. 

![Remix IDE Toolbar](/assets/lessons/1/img_1.png)

On the left hand side, in the File Explorer tab, delete all the files and folders in our workspace. We want to start fresh. Create a new folder named `contracts` and in it create a new file named `WAGMI.sol`.

The extension `.sol` is used for files in the Solidity language.

## **Now we begin writing our code**

The first line of a Solidity file is for the license, the second line lets the IDE’s compiler know which Solidity version we are working with.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;
```

The MIT license is an open source license. We at Developer DAO love open source, and we love building public goods that others are free to build on… for free! The version of Solidity we’re working with is `0.8.4` and above(`^`).

## Diving into our Smart Contracts

Virtually all smart contracts contain **variables**, data containers that can be modified, and **functions**, which are like “recipes” with instructions for those variables. When a user wants to make a transaction, the function is *called*, i.e. executed or initiated.

Let’s create our first smart contract.

It is good practice to give the same name to the contract (uppercase first letter) and the contract’s solidity file. Let’s create a contract named `WAGMI` in our `WAGMI.sol` file.

The syntax for creating a basic smart contract is as follows:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

contract WAGMI {

    // ====== This is where we will write our code ======

}
```

We can use `//` as above in Solidity to write inline comments that are not executed. As programmers we write text like this to remind ourselves and inform others what our code is supposed to do. It’s a good habit to get into! Some types of comments can even be used to automatically generate documentation, but we'll leave that lesson for later.

## How to define a variable

How can we tell the world about our future in web3? We want our contract to be able to store the message from each new user, and also record the count of messages from all future users. We might want to check on their fortunes too! So we store the message and the count in variables. Do you remember the variable = container analogy? Different **types** of variable can store different types of information, e.g. numbers, ‘strings’ of text, addresses, etc. In this case we need **state variables**. While other variables might only be used temporarily in memory, state variables live permanently in the contract which helps to make blockchain transactions transparent. For the moment, we’ll just create them as placeholders with no value, but when we interact with our smart contract later, they will be *set* with actual values.

We chose `message` and `messageCount` as our variable names, and we will assign them the **types** `string` and `uint256` respectively.

Let’s add our two state variable definitions inside our contract:

```solidity
// ...
contract WAGMI {

    string message;

    uint256 messageCount;

}
```

<ContentSideDrawer title="More on Variables and Types">

    [edit of ‘More on Variables and Types’](https://www.notion.so/edit-of-More-on-Variables-and-Types-2056c0bbe10541cfa868f1ae104b9e56)

    ### Variables
    
    There are two main forms of variables in Solidity i.e. State variables and Local variables.
    
    ![Vairables and their Scopes](/assets/lessons/1/img_2.png)
    
    A **State** variable can be accessed throughout the contract. Functions inside a contract can call and use a state variable. This is known as `global scope`. A state variable is permanently stored in the contract. Variables `message` and `messageCount` in our code are state variables.
    
    A **Local** variable is limited to the function within which it is defined and it cannot be used outside that function. This is known as `local scope`. A local variable is stored temporarily until the function in which it is defined, is executed.
    

    ### Types
    
    The type of each variable in Solidity needs to be specified. In addition, types can interact with each other in expressions containing operators (eg. comparing values).
    
    - **Value Types**: Store their own data. These are the basic data types provided by solidity. Some value types are as follows:
        - **Boolean:** This data type accepts only two values True or False.
        - **Integer:** This data type is used to store integer (a number without fractions) values, `int` and `uint` are used to declare *signed* and *unsigned integers* respectively.
        - **Address:** Address hold a 20-byte value which represents the size of an Ethereum address. An address can be used to get balance or to transfer a balance.
        - **Bytes and Strings:** Bytes are used to store a fixed-sized character set while the string is used to store the character set equal to or more than a byte. The length of bytes is from 1 to 32, while the string has a dynamic length. Byte has an advantage that it uses less gas, so better to use when we know the length of data.
    - **Reference Types**: Store the location of the data. They don’t share the data directly.
        - **Arrays:** An array is a group of variables of the same data type in which a variable has a particular location known as an index. By using the index location, the desired variable can be accessed. The array size can be of fixed or dynamic size.
        - **Struct:** Solidity allows users to create and define their own type in the form of structures. The structure is a group of different types even though it’s not possible to contain a member of its own type. The structure is a reference type variable which can contain both value types and reference types.
    - **Mapping Type**: Stores the data in a key-value pair where a key can be any value types. It is like a hash table or dictionary as in any other programming language, where data can be retrieved by key.

</ContentSideDrawer>

## Creating Functions

Our contract needs a way to store new information on the blockchain! But both our variables are *empty* and have no way of storing any info... *yet*.

That’s why we now need some **functions** to store and retrieve information to and from our contract on the blockchain. The basic syntax for a *public* function in Solidity would look like this:

```solidity
function functionName(uint256 value) public returns(bool) {

    // ====== Function logic here ======

}
```

We want to be able to read both the message and the count, so we are going to create a function to get the value for each variable. Later on we can set (store) the values, but first let’s retrieve them. We have to add two new functions below our state variable definitions. Do not delete our messageand messageCount variables and please pay attention to all the { } ; and ( ) symbols:

```solidity
// ...
contract WAGMI {

    // Don't delete our state variables here !

    function getMessage() public view returns(string memory) {
        return message;
    }

    function getMessageCount() public view returns(uint256) {
        return messageCount;
    }

}
```

Yes, there are some new keywords up there e.g. return, returns, view, etc, but don’t panic:

`public` defines the **visibility** of our function and means it can be called from anywhere e.g. directly calling it with our externally owned address (e.g. our crypto wallet), from another smart contract, or even from another function inside our smart contract. We can use a public function for making a transaction, or querying a value from a contract.

`view` means the function **can’t** modify the blockchain state, so it doesn’t store any value or trigger a transaction by itself. It is useful for querying information from a contract, such as an account balance.

`memory` tells us where the variable lives (for some types we have to tell solidity if a variable is in `memory`, `storage`or `calldata`). We can leave these concepts for future lessons, or if you can’t wait that long, you can read some more about them in **Variables** and **Functions**.

<ContentSideDrawer title="More on Functions">
    
    [edits: More on Functions ](https://www.notion.so/edits-More-on-Functions-f2e049d12a264040b23c8f562d63f6c6)
    
    Functions are the way we have to store logic inside a Smart Contract.
    
    They can receive typed parameters and also return them. Solidity is a typed language, so every parameter type must be specified.
    
    Writing data to the blockchain has cost, thus reference type parameters must indicate the data location. From more expensive to more cheap, these parameters can be in:
    
    - **storage**: it is a reference to stored data in the blockchain
    - **memory**: it is a reference to a place in memory
    - **calldata**: it is a read-only area where function parameters are stored. It behaves mostly like memory.
    
    Functions can have different purposes. In solidity we have to define what a function will be able to do (to asses if the function call will spend gas or not). A function can be:
    
    - **view**: it doesn’t write data to the blockchain state
    - **pure**: it doesn’t write or read data to or from the blockchain state
    
    If none of these is specified, it is assumed the function can write to the blockchain state and it will **always** spend gas when called.
    
    Also, since we can transfer value in the blockchain, we can specify another modifier:
    
    - **payable**: A function that can receive funds (ETH)
    
    Lastly, functions in smart contracts can be called from a varying set of points. For that we have visibility modifiers:
    
    - **external**: can be called from other contracts via transactions, but not internally (not directly)
    - **public**: can be called internally or from another contract
    - **internal**: can only be accessed from within the contract or contracts deriving from it. They cannot be accessed externally.
    - **private**: same as internal, but they are not visible in derived contracts

</ContentSideDrawer>

Ok, now we have to figure out a way to store some info on our contract!

We want to *set* a new message in our contract, so now we define a new function below the ones we recently created. The function should receive a new message as a parameter, store it in our state variable and also update the message count:

```solidity
function setMessage(string calldata newMessage) public {

    // We add 1 to the messageCount state variable
    messageCount++;

    // We update the message state variable
    message = newMessage;
}
```

If you noticed, this function, unlike the previous ones, does not have the view visibility keyword and it does indeed modify the state of our contract and the blockchain. Therefore, whenever someone calls this function in the future, their wallet is going to ask them to confirm a transaction on the blockchain. That means it will use some gas, which is a transaction fee of a small amount of eth, since we are using the Ethereum blockchain. As we progress on our learning journey we will hear a lot more about Gas and Fees, but that’s also for future lessons.

## Events and dealing with on-chain storage

So far, we’ve learned to how make our contract store a message on the blockchain, and how we can use a function to retrieve it. But every time we store a new message, we overwrite the old one.

We would love to have a history of the messages, but storing everything on-chain is expensive and uses that precious space we mentioned before. When we do a deep dive into the fundamentals of nodes and storage, you’ll understand why it’s precious. Fortunately we have some mechanisms to overcome some of these storage issues and access information we might need.

Every transaction has a **transaction log** where we can store a limited amount of information more cheaply than we could on the actual blockchain. Transaction logs are not accessible from our smart contract, but after we’ve developed our user facing front-end app, we will be able to read them from any Ethereum **node**. And because Remix emulates a node, the logs are provided for us.

To create a transaction log, we need to **define** an `event` in the contract, and then we can make one of our functions **emit** that event to the blockchain nodes. The values used in the event’s **parameters** will be stored in the transaction logs.…. **Definition of parameter here….or in the Indexed Events Parameter dropdown.** 

We usually define our events near the top of the contract, under the state variables. The basic syntax for defining an event with 3 parameters would be:

```solidity
event EventName(uint256 indexed param1, bool param2, string param3);
```

In Solidity, there are two types of event parameter. The first type we define with our indexed keyword. By using a search filter on an indexed parameter we can find a past event on the blockchain. The other type is simply not indexed and therefore not searchable. Each event can have multiple parameters, but only three can be indexed. When you see the transaction logs in Remix, it should help it make more sense.

<ContentSideDrawer title="Indexed Event Parameters">
    
    Blockchain keeps event parameters in transaction logs. Transaction logs remains in the blockchain as long as the block is accessible.
    
    Event parameters can be either `indexed` or not indexed.
    
    Based on that, parameters will be stored in different parts of the transaction log: **topics** and **data**.
    
    - `indexed` parameters will be stored in the **topics** sections of the log
    - non-indexed parameters will be ABI-encoded into the **data** portion of the log
    
    Once the event data is stored inside the transaction log in a block, we can later on filter events.
    
    We can filter events by name and by contract address, and by any parameters stored in the topics part of the logs, hence using the `indexed` keyword, we have a way to retrieve specific events emitted.
    
    For example, we can search for all the Transfers of a certain ERC20 Token, from or to a specific address.

</ContentSideDrawer>

Each time that ‘something happens’ e.g. someone calls setMessage, our function will emit the event and create a log. Thus, to emit one using the example event above we can write:

```solidity
emit EventName(2, false, 'Hello World!');
```

There’s a lot to unpack, so we’ll leave it there for now! Let’s create an event to log all the future messages sent to our smart contract and check the fortunes to see if the sent messages are worthy of “making it” in the web3 world. 😉

After our state variables, we can define our new event as:

```solidity
// We add this line after our 'message' and 'messageCount' definitions
event web3Future(uint256 indexed messageIndex, address indexed author, string message, string future);
```

Notice that our second parameter is defined with a new type: `address`. We use this type for Ethereum addresses, whether they’re user **wallet** addresses or addresses of other **smart contracts**. Yes, that is also for another lesson 😉 

Inside our `setMessage` function, we should emit the event. But before that, let’s decide if the message is GMI or NGMI:

```solidity
function setMessage(string calldata newMessage) public {

    // We leave our previous code
    messageCount++;

    message = newMessage;

    // ====== Here begins our new code ======

    // We create a local variable in memory to decide if GMI or NGMI
    string memory future = 'NGMI';

    // Only if the new message is 'gm', we change it to a fun response ;o)
    if (keccak256(abi.encodePacked(newMessage)) == keccak256(abi.encodePacked('gm'))) {
        future = 'WAGMI';
    }

    // We emit the event notifying the change of our state variable
    emit web3Future(messageCount, msg.sender, newMessage, future);

    // ====== End of new code ======
}
```

If you were wondering what msg.sender is, we can simplify it as the Ethereum address that called the function. You also probably noticed how we compare newMessage with ‘gm’. That’s because Solidity doesn’t have a way to easily compare two strings of text, so with a little bit of encoding and decoding, we are using abi.encodePacked() to convert the string into bytes and then using the hashing function keccak256() to compare the two “hashes”, and if they are equal, the strings are equal too 🙌.  You can be sure that we’ll be deep diving on these in future lessons, so no worries!

<ContentSideDrawer title="More on Events">
    
    In the Ethereum Blockchain, whenever we run or execute a transaction it stores a log with the results and data of the transaction. Solidity provides us with **Events** so we can write data to said logs.
    
    Applications can subscribe and listen to this events, or even search for past logs using filters.
    
    Whenever a function calls (**emits**) an event, the values passed as parameters are stored in a special data structure in the blockchain: the transaction log. It is worth noticing that Smart Contracts cannot access the log and its event data.
    
    If we define a parameter as `indexed`, instead of being added to the data part of the log, it is added to a special data structure called **topics** instead of the data part of the log. A topic can only hold a single word of 32 bytes, so if we use a **reference type**, only its hash is stored (using keccak-256). Each event can **only** hold a maximum of 3 `indexed` parameters.
    
    Topics are what lets us search for events in the blockchain logs. We can filter them by a specific event, the contract address that emitted them,  and any indexed parameters defined in the event.

</ContentSideDrawer>    

We should ask the learner to sum up what they have learned. 
Some checkpoint questions:

Addresses: Apart from a user wallet, what else uses a blockchain (Ethereum) address?

Events: How many parameters can we have in an event?

Searching the chain: What can we use to find a past event?

Transactions: Ethereum uses something for transaction fees. What’s it called?

Logs: Where do the values for event parameters get stored?

Versions: What is the use of the **pragma solidity** statement in
our smart contract?

State variables: Do state variables stay permanently on the blockchain?

Visibility: Can a view function modify the state of the blockchain?

Use cases of smart contract: What can we use a smart contract for?

see the Comment in the very last line of this lesson under ‘Now, please go ahead and hop in the forum/discord to tell us: what is your future in web3?’ 

## Compile & Deploy

Now that we have written our smart contract in full, we can compile it and deploy it to a blockchain. Since we are using the Remix IDE, we can use its tools in the sidebar for this. Here’s a brief description of the tools icons:

![Remix Menu](/assets/lessons/1/img_3.png)

At the top, the logo links us to the Home (and Help links) of Remix 

Then, we have our File Explorer

The magnifying glass icon is for searching in files

Highlighted in red, the Solidity Compiler (our next step)

Highlighted in red, the Solidity Compiler (our next step)

To compile our smart contract we should click on the **Solidity Compiler** icon in the sidebar (marked in the red box).

Leave all the settings in their default, manually select our contract in the drop down menu and click on the **Compile WAGMI.sol** button.

![Remix Contract Compiler Button](/assets/lessons/1/img_4.png)

![Remix Successful Compilation Indicator](/assets/lessons/1/img_5.png)

After compiling, we should see a green check mark on top of the Solidity Compiler sidebar icon.

<ContentSideDrawer title="Problems at Compile time">
    
    First, check that you have selected a compiler compatible with our version (0.8.4 or any higher inside the 0.8 version).
    
    If you still have any problems when compiling, you can compare your code to my final code. Mine looks like this (with most comments removed for readability):
    
    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.4;
    
    contract WAGMI {
    
        // State Variables
        string message;
        uint256 messageCount;
    
        // Events
        event Web3Future(uint256 indexed messageIndex, address indexed author, string message, string future);
    
        // Functions
        function getMessage() public view returns(string memory) {
            return message;
        }
    
        function getMessageCount() public view returns(uint256) {
            return messageCount;
        }
    
        function setMessage(string calldata newMessage) public {
            messageCount++;
            message = newMessage;
    
            string memory future = 'NGMI';
            if (keccak256(abi.encodePacked(newMessage)) == keccak256(abi.encodePacked('gm'))) {
                future = 'WAGMI';
            }
    
            emit Web3Future(messageCount, msg.sender, newMessage, future);
        }
    
    }
    ```
    
</ContentSideDrawer>    

Now we are ready to deploy our contract. We can now head to the Deploy & Run transactions icon in the sidebar (marked in the green box). Below we can see a message that says ‘Currently you have no contract instances to interact with’, so we haven’t deployed anything yet.

![Contract Instance Warning](/assets/lessons/1/img_6.png)

Again, we are leaving all options to default for now (we’ll be learning how to deploy to a testnet later on). Click on the **Deploy** button!

Once deployment finishes, we are going to see our shiny new deployed contract instance below.

Open the dropdown under ‘Deployed Contracts’, to see our function tabs:

- the blue ones are our “**view**” functions that doesn’t modify our state
- the orange one lets us trigger the setMessage function which will change the state. Be sure to click on the little drop down menu on the right. From here on, we can interact with our contract. Feel free to test the functions. Click on the getMessage and messageCount tabs before and after setting a new message. modify data on our contract.

![Available Interactive Options once Contract is Deployed](/assets/lessons/1/img_7.png)

From here on, we can interact with our contract. Feel free to test the functions. Click on the getMessage and messageCount tabs before and after setting a new message.

On the right hand side, below our contract code, there’s a bar on the bottom. If it hasn’t opened automatically, we can open the console from here to see any transactions with the green check mark. The first transaction is the deployment of our contract. Click it to open it.ons with the green check mark. The first transaction is the deployment of our contract. Click it to open it.

![Button to Minimise and Maximise Console](/assets/lessons/1/img_8.png)

Once you set a new message, you’ll see again, that the transaction has a green check mark, open it and look for the “logs”. Here’s my info after setting the message to “My first smart contract”:

![Complete Transaction Log of Deployed Contract](/assets/lessons/1/img_9.png)

If you look closely, inside the “logs” part, our smart contract predicted a “future” for us.

What if you try out setting the message to `gm` and look at the logs again. Can you see the magical spell that is being cast here?

![Wizard Wooshing on Successful Lesson](/assets/lessons/1/img_10.png)

Before you go ahead and tell us: **what your future in web3 is,** have a check on what you didn’t know a little while ago, and what you know now!
**Fellow devs: the answers to these questions are in each comment. Could we use a simple form for this for now with just a hover over the question to display the answer (or something more creative). The user wouldn’t have to actually answer the questions for MVP, but we want to let them self test, using their own trust to see what they do and don’t know at this stage. On top of that, we want to get some feedback as to the nature of the questions and maybe get some feedback on the actual presentation style/method which is pretty unadventurous here, so we can get creative and also more meaningful later.** 

Addresses: Apart from a user wallet, what else uses a blockchain (Ethereum) address?

Events: How many parameters can we have in an event?

Searching the chain: What can we use to find a past event?

Transactions: Ethereum uses something for transaction fees. What’s it called?

Logs: Where do the values for event parameters get stored?

Versions: What is the use of the **pragma solidity** statement in
our smart contract?

State variables: Do state variables stay permanently on the blockchain?

Visibility: Can a view function modify the state of the blockchain?

Use cases of smart contract: What can we use a smart contract for?

**Now, go to the community in Discord to share your new Open Sourcerer powers**!!!