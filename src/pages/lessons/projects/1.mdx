---
title: Getting Started with Smart Contract Development
description: Learn Basics of Smart Contract Development and Remix.
icons: ["solidity", "remix"]
---

import { LessonHeader } from "../../../components/mdx/LessonHeader";
import Layout from "../../../components/Layout";

<Layout
    title="Dapp Page" 
    description="A page for your dapp." 
>
<LessonHeader title="Lesson 1: Intro to Smart Contract Development" />

## About this lesson

Welcome to our introductory lesson on smart contract development, blockchain
fundamentals and your first taste of coding with the Solidity language. For this
lesson, you don‚Äôt really need to have development experience, although we expect
you to have a ‚Äòtechnical mindset‚Äô to be able to proceed. We would recommend
_Build a basic NFT_ as a subsequent lesson for getting familiar with more
advanced concepts and developer tooling. But first things first.

We have some questions for you throughout the lesson for testing your previous
knowledge, predicting next steps in the lesson, and letting you see for yourself
how well you're absorbing the new content. There's also a quiz at the end, of
course, so make sure you're checking out all the side-drawers for a deeper dive
of any new concepts. To complete the lesson, expect somewhere between one and
four hours depending on your previous experience and the need to learn new
ideas. Remember your well-being and set the pomodoro timer in the menu header to
ensure you‚Äôre taking regular breaks, and please do go outside and 'touch some
grass‚Äô.

## What are we building?

We‚Äôre going to build a **smart contract**, but what on Jupiter is a smart
contract? And what on Earth would we use one for? Well, you wouldn‚Äôt find a
smart contract on either Jupiter, or Earth, and although you may be grounded to
the latter, you are going to deploy yours on a **blockchain**. Not a real
blockchain, well not at first. Hang on!

Let's pause here for a couple questions to give you a taste of what's to come
and give yourself a chance to test what you already know.

<SideDrawer buttonText="Warm-up Questions" title="Warm-up Questions">
  <Question question="lesson-1/intro-Q1" />
  <Question question="lesson-1/intro-Q2" />
  <Question question="lesson-1/intro-Q3" />
</SideDrawer>
<br />

How was that? No stress if the answers didn't come naturally. We're here to fill
in the gaps! If you're interested in more context before moving along to the
lesson, check out the explainers below.

<SideDrawer buttonText="What is a Blockchain?">
A blockchain has quite a few layers to let function, but it basically gives us
a place to do computation, and store information. So in one sense it functions
as a database. Think about this: to get access to all of the information on a
traditional database you need permission from a higher authority, right? Access
to information on a public blockchain is permission**less**. Not only can we read
the information on it, but anyone can also write information to it. And that‚Äôs
where we come in and get this all started with our *smart contract*. And what is
also different to a traditional database is that once the information goes onto
this blockchain, it stays there forever, and ever, and ever... thanks to
cryptography!

But what is the information that is kept on this chain? Wait. Why a chain? Well
basically transactions, often, but not always, financial, are made and recorded
and bundled into blocks of a limited capacity and they keep getting added on to
make a continuing _block chain_. Each transaction contains quite a limited
amount of information, but gives us transparency so that anyone can trace the
_money trail_. And this was one of the main intentions of blockchains.
Transparency. There are ever-growing use cases for the types of transactions,
financial and non-financial. Let‚Äôs move on. The blocks are secured to each other
with cryptography. A similar type of encryption that is used to secure the
Signal or Telegram apps on your smartphone. If someone did try to change any
information on the chain, the alarm bells would go off.

So how is all this permission**lessness** possible? Can‚Äôt someone shut this
blockchain down? Simply put, no. A public blockchain actually runs on a network
of computers, which can be distributed all around the world. We call each of
these computers a node when they run a programme called ‚Äòclient‚Äô software, which
lets the whole network communicate‚Ä¶ and nobody is in charge. Some blockchains
have tens of thousands of nodes across dozens of countries.

To maintain, or run a node and the software, you need to be slightly technically
minded, and there are a couple of other requirements and considerations which
we‚Äôll discuss in later lessons, but what is important to appreciate, is that the
people running their computers as nodes on the network for the most part don‚Äôt
know each other. So thanks to this decentralized reality, the nodes can‚Äôt
collaborate with each other in great enough numbers to form a 51% group and take
over the whole network, so there is no higher authority.

So we have what is like a global computer which is permissionless, transparent
and distributed, and as long as 66% of the nodes are running, the blockchain can
keep on going quite safely, which makes it almost completely censorship
resistant. Think about that for a second. And it gets better...

Really? What‚Äôs so special about all of this? Well until recently, we only
transferred data on the internet. Yes, you could send money too by using some
kind of banking app, or financial services app like Western Union, but with the
advent of cryptocurrencies we can now send _digital_ value‚Ä¶ permissionlessly.
That's quite a thing! In the early days of crypto we could only transact with
digital tokens such as BTC and then ETH and soon later, with thousands of
different coins. But new ideas continue to emerge and we‚Äôre going to be building
a few of them!

The distributed sharing of value on blockchain has opened up further development
of networks that for example facilitates the distribution of storage, where,
like running a blockchain node, people can use their home computer‚Äôs storage
device for storing other people‚Äôs data, and earn a bit of money in return.
That‚Äôs where your NFTs (will) live! Many, many more internet services, or
protocols that have been centralized until now have emerged to complement and
add extra functionality to all of the above, and many completely new protocols
are being added really quickly! So you are going to hear words like
composability, interoperability, money-legos, etc. We are also finally getting
to a stage of internet evolution where we can own our personal data again and be
able to transfer value without worrying about a middleman saying if we can or
can‚Äôt.

This is what we call Web3. Welcome!

So back to the smart contract. What the hell is it? It‚Äôs a piece of computer
code that will do whatever we programme it to do. And once we have written and
rigorously tested the code, we _deploy_ it to the blockchain, once and for all,
where it will live there happily ever after. Unless we mess up something when
writing the code, where it will live there very, very unhappily ever after. With
lots of very unhappy people. Unlike your smartphone apps, or your operating
system that can have updates once in a while, you can‚Äôt just decide to rewrite a
smart contract, or update it, unless you actually create it with that
functionality, but quite often there are good reasons why you won‚Äôt want to. So
when we write a contract, we have to be smart too! The most common use for a
smart contract is to store or transfer value and the last thing we want is them
to be compromised in any way. So let‚Äôs get used to the idea of test, test,
testing them.

Last but not least, the end user. The user accesses the blockchain through a
user interface that we call a wallet address, because it lets us interact with
crypto tokens and sign the smart contracts we interact with. Any address on the
blockchain looks something like this:
0x450904F9c3eab65812963d17790ca2615555fD64. These addresses are an integral
means of communication on and with any blockchain. Not only does a user have an
address like this, but all the smart contracts on the blockchain have one as
well, and use them as a means of communication too. Like phone numbers, or
emails blockchain style! It‚Äôs becoming more common that a user will have an
easier to remember alias for their address, e.g., imsoeasy.eth!

</SideDrawer>

<SideDrawer buttonText="What is a Smart Contract?">

A smart contract, as it suggests is a contract, but written into computer code
and stored and executed on a blockchain. But what does it let us do? In simple
terms, it allows two parties to buy and sell something and confirm their
signatures to close the sale.

Until now, buying and selling of crypto tokens, and more recently NFTs, have
seen most of the ‚Äòon-chain‚Äô activity and news coverage, but there is much, much
more and the use cases for smart contracts on and off-chain is growing at an
exponential rate, therefore the development of them couldn‚Äôt be more exciting.

Humans have been buying, selling and signing contracts for millennia, so what is
new here? We don‚Äôt need a third party, central authority or any kind of legal
system to verify the transaction. The contract is in the code, the users sign it
and the contract ‚Äòsmartly‚Äô self-executes, in other words permissionlessly.
Because the blockchains that we are learning about are heavily decentralised, it
makes this all possible. And there are many more benefits to this decentralised
model as we‚Äôll continue to see.

</SideDrawer>
Did you set the pomodoro? ‚åõüòä

## What are we going to do?

By the end of this lesson we‚Äôll have learned a lot. A simple breakdown of the
steps to get there is:

- Set up our work environment
- Create a Smart Contract
- Learn basic Solidity concepts
- Define variables
- Create a function
- Learn about events on the blockchain
- Deploy our Smart Contract in Remix

At the end of the project, we‚Äôre really going to test your knowledge with a
quiz, so take in whatever you can. We might even have some questions along the
way for fun to expand your already amazing mind!

## Let‚Äôs get this party started!

We‚Äôre going to write a smart contract, which is going to be a ‚ÄúWeb3
fortune-teller". The idea is that you will input a message into the contract,
the contract will decode the message, and like a fortune-teller would do,
predict your future‚Ä¶ in Web3.

Before we start, we need a place to write our Solidity language smart contract,
and some tools to run it. For that we use the Remix IDE, short for...

<SideDrawer buttonText="Integrated Development Environment">

So what is actually integrated into this environment of Remix and what do we
need it for? For a start, it‚Äôs a tool in your browser which emulates a
blockchain stack. Since it has a lot of the features needed to run a smart
contract, it let‚Äôs us get started with learning how to develop one and see how
it would work on a live network and also some of the things a user would
experience on a front end application. Experienced developers still use it too
because it is so handy for a lot of things. It‚Äôs a pretty nifty tool! It has:

A `file explorer`: a place to write and store your smart contracts and files of
code as you work with them online.

A `compiler`: for your Solidity code, which will let you know if your contract
code is bug free, and then compile it for you. Compiling is basically
translating it into another programming language that the blockchain can work
with.

A `batch of 10 wallet addresses` which you can use and interact with while you
work.

A `deployer`, which places the contract on the emulated blockchain after it‚Äôs
compiled and lets you play around with its functions and learn about them and
their outputs.

A `‚Äòterminal‚Äô` window where you can read all the output and logs from each time
you interact with the contract. This is what you would expect to see on a
working blockchain validator‚Äôs node.

There are a lot more features in Remix, but those are the ones we‚Äôll be working
with.

</SideDrawer>

## Setting up Remix (IDE)

To get started we will use the Remix IDE to write, compile, test and debug code
quickly and easily. Head over to
[https://remix.ethereum.org/](https://remix.ethereum.org/) to see what it‚Äôs all
about and get started.

![Remix IDE Toolbar](/assets/lessons/1/img_1.png)

On the left hand side, in the File Explorer tab, delete all the files and
folders in our workspace. We want to start fresh. Create a new folder named
`contracts` and in it create a new file named `WAGMI.sol`.

The extension `.sol` is used for files in the Solidity language.

<SideDrawer
  buttonText="Checkpoint Questions"
  title="Blockchain and Solidity Smart Contracts"
>
  <Question question="lesson-1/tooling-Q1" />
  <Question question="lesson-1/tooling-Q2" />
  <Question question="lesson-1/tooling-Q3" />
  <Question question="lesson-1/tooling-Q4" />
</SideDrawer>
<br />

Well done! Now, go touch some grass! ‚åõüòä

## **Now we begin writing our code**

The first line of a Solidity file is for the license, the second line lets the
IDE‚Äôs compiler know which Solidity version we are working with.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;
```

The MIT license is an open source license. We at Developer DAO love open source,
and we love building public goods that others are free to build on‚Ä¶ for free!
The version of Solidity we‚Äôre working with is `0.8.4` and above(`^`).

## Diving into our Smart Contracts

Virtually all smart contracts contain **variables**, data containers that can be
modified, and **functions**, which are like ‚Äúrecipes‚Äù with instructions for
those variables. When a user wants to make a transaction, the function is
_called_, i.e. executed or initiated.

Let‚Äôs create our first smart contract.

It is good practice to give the same name to the contract (uppercase first
letter) and the contract‚Äôs solidity file. Let‚Äôs create a contract named `WAGMI`
in our `WAGMI.sol` file.

The syntax for creating a basic smart contract is as follows:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

contract WAGMI {

    // ====== This is where we will write our code ======

}
```

We can use `//` as above in Solidity to write inline comments that are not
executed. As programmers we write text like this to remind ourselves and inform
others what our code is supposed to do. It‚Äôs a good habit to get into! Some
types of comments can even be used to automatically generate documentation, but
we'll leave that lesson for later.

## How to define a variable

How can we tell the world about our future in web3? We want our contract to be
able to store the message from each new user, and also record the count of
messages from all future users. We might want to check on their fortunes too! So
we store the message and the count in variables. Do you remember the variable =
container analogy? Different **types** of variable can store different types of
information, e.g. numbers, ‚Äòstrings‚Äô of text, addresses, etc. In this case we
need **state variables**. While other variables might only be used temporarily
in memory, state variables live permanently in the contract which helps to make
blockchain transactions transparent. For the moment, we‚Äôll just create them as
placeholders with no value, but when we interact with our smart contract later,
they will be _set_ with actual values.

We chose `message` and `messageCount` as our variable names, and we will assign
them the **types** `string` and `uint256` respectively.

Let‚Äôs add our two state variable definitions inside our contract:

```solidity
// ...
contract WAGMI {

    string message;

    uint256 messageCount;

}
```

<SideDrawer buttonText="More on Variables and Types">

    ### Variables

    There are two main forms of variables in Solidity i.e. State variables and Local variables.

    ![Vairables and their Scopes](/assets/lessons/1/img_2.png)

    A **State** variable can be accessed throughout the contract. Functions inside a contract can call and use a state variable. This is known as `global scope`. A state variable is permanently stored in the contract. Variables `message` and `messageCount` in our code are state variables.

    A **Local** variable is limited to the function within which it is defined and it cannot be used outside that function. This is known as `local scope`. A local variable is stored temporarily until the function in which it is defined, is executed.


    ### Types

    The type of each variable in Solidity needs to be specified. In addition, types can interact with each other in expressions containing operators (eg. comparing values).

    - **Value Types**: Store their own data. These are the basic data types provided by solidity. Some value types are as follows:
        - **Boolean:**¬†This data type accepts only two values True or False.
        - **Integer:**¬†This data type is used to store integer (a number without fractions) values,¬†`int`¬†and¬†`uint`¬†are used to declare¬†*signed*¬†and¬†*unsigned integers*¬†respectively.
        - **Address:**¬†Address hold a 20-byte value which represents the size of an¬†Ethereum address. An address can be used to get balance or to transfer a balance.
        - **Bytes and Strings:**¬†Bytes are used to store a fixed-sized character set while the string is used to store the character set equal to or more than a byte. The length of bytes is from 1 to 32, while the string has a dynamic length. Byte has an advantage that it uses less gas, so better to use when we know the length of data.
    - **Reference Types**: Store the location of the data. They don‚Äôt share the data directly.
        - **Arrays:**¬†An array is a group of variables of the same data type in which a variable has a particular location known as an index. By using the index location, the desired variable can be accessed. The array size can be of fixed or dynamic size.
        - **Struct:**¬†Solidity allows users to create and define their own type in the form of structures. The structure is a group of different types even though it‚Äôs not possible to contain a member of its own type. The structure is a reference type variable which can contain both value types and reference types.
    - **Mapping Type**: Stores the data in a key-value pair where a key can be any value types. It is like a hash table or dictionary as in any other programming language, where data can be retrieved by key.

    ### Visibility of State Variables

    In Solidity, there are 3 types of variable visibility modifiers that a developer can use :

    - **Public**: If a state variable visibility is marked as `public` then those variables can be used within the smart contract and can be accessed by other contracts as well. Compilers automatically generates functions to read its value when calling the contract, they are called 'getter' functions.

    - **Internal**: A state variable with an `internal` visibility can only be accessed within the smart contract and its derived contracts. It can *NOT* be accessed externally. This is the default for state variables when no visibility is specified.

    - **Private**: When a state variable visibility is marked as `private` it is only meant to be used within the defined smart contract. No derived contract can read a variable with a `private` visibility.

    <Callout emoji='üí°' size='md' variant='info'>
    While private and internal are not readable or modifiable from other contracts, its values are set on a public blockchain, making its values visible from the outside world.
    </Callout>

    #### Which visibility should I use?

    A simple answer to this is, start by giving every variable a `private` visibility then as you move further in contract development modify variables to `internal` visibility as a next step of modification. Try to use `public` visibility as little as possible in order to be gas efficient and making less vulnerabilities in the smart contract.

</SideDrawer>

## Creating Functions

Our contract needs a way to store new information on the blockchain! But both
our variables are _empty_ and have no way of storing any info... _yet_.

That‚Äôs why we now need some **functions** to store and retrieve information to
and from our contract on the blockchain. The basic syntax for a _public_
function in Solidity would look like this:

```solidity
function functionName(uint256 value) public returns(bool) {

    // ====== Function logic here ======

}
```

We want to be able to read both the message and the count, so we are going to
create a function to get the value for each variable. Later on we can set
(store) the values, but first let‚Äôs retrieve them. We have to add two new
functions below our state variable definitions. Do not delete our message and
messageCount variables and please pay attention to all the { } ; and ( )
symbols:

```solidity
// ...
contract WAGMI {

    // Don't delete our state variables here!

    function getMessage() public view returns(string memory) {
        return message;
    }

    function getMessageCount() public view returns(uint256) {
        return messageCount;
    }

}
```

Yes, there are some new keywords up there e.g. **return**, **returns**,
**view**, etc, but don‚Äôt panic:

`public` defines the **visibility** of our function and means it can be called
from anywhere e.g. directly calling it with our externally owned address (e.g.
our crypto wallet), from another smart contract, or even from another function
inside our smart contract. We can use a public function for making a
transaction, or querying a value from a contract.

`view` means the function **can‚Äôt** modify the blockchain state, so it doesn‚Äôt
store any value or trigger a transaction by itself. It is useful for querying
information from a contract, such as an account balance.

`memory` tells us where the variable lives (for some types we have to tell
solidity if a variable is in `memory`, `storage`or `calldata`). We can leave
these concepts for future lessons, or if you can‚Äôt wait that long, you can read
some more about them in **More on Functions**.

<SideDrawer buttonText="More on Functions">
    
    Functions are the way we have to store logic inside a Smart Contract.
    
    They can receive typed parameters and also return them. Solidity is a typed language, so every parameter type must be specified.
    
    Writing data to the blockchain has cost, thus reference type parameters must indicate the data location. From more expensive to more cheap, these parameters can be in:
    
    - **storage**: it is a reference to stored data in the blockchain
    - **memory**: it is a reference to a place in memory
    - **calldata**: it is a read-only area where function parameters are stored. It behaves mostly like memory.
    
    Functions can have different purposes. In solidity we have to define what a function will be able to do (to asses if the function call will spend gas or not). A function can be:
    
    - **view**: it doesn‚Äôt write data to the blockchain state
    - **pure**: it doesn‚Äôt write or read data to or from the blockchain state
    
    If none of these is specified, it is assumed the function can write to the blockchain state and it will **always** spend gas when called.
    
    Also, since we can transfer value in the blockchain, we can specify another modifier:
    
    - **payable**: A function that can receive funds (ETH)
    
    Lastly, functions in smart contracts can be called from a varying set of points. For that we have visibility modifiers:
    
    - **external**: can be called from other contracts via transactions, but not internally (not directly)
    - **public**: can be called internally or from another contract
    - **internal**: can only be accessed from within the contract or contracts deriving from it. They cannot be accessed externally.
    - **private**: same as internal, but they are not visible in derived contracts

</SideDrawer>

Ok, now we have to figure out a way to store some info on our contract!

We want to _set_ a new message in our contract, so now we define a new function
below the ones we recently created. The function should receive a new message as
a parameter, store it in our state variable and also update the message count:

```solidity
function setMessage(string calldata newMessage) public {

    // We add 1 to the messageCount state variable
    messageCount++;

    // We update the message state variable
    message = newMessage;
}
```

If you noticed, this function, unlike the previous ones, does not have the
**view** visibility keyword and it does indeed modify the state of our contract
and the blockchain. Therefore, whenever someone calls this function in the
future, their wallet is going to ask them to confirm a transaction on the
blockchain. That means it will use some _gas_, which is a transaction fee of a
small amount of eth, since we are using the Ethereum blockchain. As we progress
on our learning journey we will hear a lot more about gas and fees, but that‚Äôs
also for future lessons.

<SideDrawer buttonText="Checkpoint Questions" title="Variables and Functions">
  <Question question="lesson-1/varsFunctions-Q1" />
  <Question question="lesson-1/varsFunctions-Q2" />
  <Question question="lesson-1/varsFunctions-Q3" />
  <Question question="lesson-1/varsFunctions-Q4" />
</SideDrawer>
<br />

Go touch some grass and set the pomodoro when you return ‚åõüòä

## Events and dealing with on-chain storage

So far, we‚Äôve learned to how make our contract store a message on the
blockchain, and how we can use a function to retrieve it. But every time we
store a new message, we overwrite the old one.

We would love to have a history of the messages, but storing everything on-chain
is expensive and uses that precious space we mentioned before. When we do a deep
dive into the fundamentals of nodes and storage, you‚Äôll understand why it‚Äôs
precious. Fortunately we have some mechanisms to overcome some of these storage
issues and access information we might need.

Every transaction has a **transaction log** where we can store a limited amount
of information more cheaply than we could on the actual blockchain. Transaction
logs are not accessible from our smart contract, but after we‚Äôve developed our
user facing front-end app, we will be able to read them from any Ethereum
**node**. And because Remix emulates a node, the logs are provided for us.

To create a transaction log, we need to **define** an `event` in the contract,
and then we can make one of our functions **emit** that event to the blockchain
nodes. The values used in the event‚Äôs **parameters** will be stored in the
transaction logs.

We usually define our events near the top of the contract, under the state
variables. The basic syntax for defining an event with 3 parameters would be:

```solidity
event EventName(uint256 indexed param1, bool param2, string param3);
```

In Solidity, there are two types of event parameter. The first type we define
with our indexed keyword. By using a search filter on an indexed parameter we
can find a past event on the blockchain. The other type is simply not indexed
and therefore not searchable. Each event can have multiple parameters, but only
three can be indexed. When you see the transaction logs in Remix, it should help
it make more sense.

<SideDrawer buttonText="Indexed Event Parameters">
    
    Blockchain keeps event parameters in transaction logs. Transaction logs remains in the blockchain as long as the block is accessible.
    
    Event parameters can be either `indexed` or not indexed.
    
    Based on that, parameters will be stored in different parts of the transaction log: **topics** and **data**.
    
    - `indexed` parameters will be stored in the **topics** sections of the log
    - non-indexed parameters will be ABI-encoded into the **data** portion of the log
    
    Once the event data is stored inside the transaction log in a block, we can later on filter events.
    
    We can filter events by name and by contract address, and by any parameters stored in the topics part of the logs, hence using the `indexed` keyword, we have a way to retrieve specific events emitted.
    
    For example, we can search for all the Transfers of a certain ERC20 Token, from or to a specific address.

</SideDrawer>

Each time that ‚Äòsomething happens‚Äô e.g. someone calls setMessage, our function
will emit the event and create a log. Thus, to emit one using the example event
above we can write:

```solidity
emit EventName(2, false, 'Hello World!');
```

There‚Äôs a lot to unpack, so we‚Äôll leave it there for now!

Let‚Äôs create an event to log all the future messages sent to our smart contract
and check the fortunes to see if the sent messages are worthy of ‚Äúmaking it‚Äù in
the web3 world. üòâ After our state variables, we can define our new event as:

```solidity
// We add this line after our 'message' and 'messageCount' definitions
event web3Future(uint256 indexed messageIndex, address indexed author, string message, string future);
```

Notice that our second parameter is defined with a new type: `address`. We use
this type for Ethereum addresses, whether they‚Äôre user **wallet** addresses, or
addresses of other **smart contracts**. Yes, that is too for another lesson üòâ

Inside our `setMessage` function, we should emit the event. But before that,
let‚Äôs decide if the message is GMI or NGMI:

```solidity
function setMessage(string calldata newMessage) public {

    // We leave our previous code
    messageCount++;

    message = newMessage;

    // ====== Here begins our new code ======

    // We create a local variable in memory to decide if GMI or NGMI
    string memory future = 'NGMI';

    // Only if the new message is 'gm', we change it to a fun response ;o)
    if (keccak256(abi.encodePacked(newMessage)) == keccak256(abi.encodePacked('gm'))) {
        future = 'WAGMI';
    }

    // We emit the event notifying the change of our state variable
    emit web3Future(messageCount, msg.sender, newMessage, future);

    // ====== End of new code ======
}
```

If you were wondering what **msg.sender** is, we can simplify it as the Ethereum
address that called the function. You also probably noticed how we compare
newMessage with ‚Äògm‚Äô. That‚Äôs because Solidity doesn‚Äôt have a way to easily
compare two strings of text. But with a little bit of encoding and decoding, we
can use abi.encodePacked() to convert the string into bytes and then use the
hashing function keccak256() to compare the two **hashes**. And if _they_ are
equal, the strings are equal too üôå. You can be sure that we‚Äôll be deep diving
on these in future lessons, so no worries!

<SideDrawer buttonText="More on Events">
    
    In the Ethereum Blockchain, whenever we run or execute a transaction it stores a log with the results and data of the transaction. Solidity provides us with **Events** so we can write data to said logs.
    
    Applications can subscribe and listen to these events, or even search for past logs using filters.
    
    Whenever a function calls (**emits**) an event, the values passed as parameters are stored in a special data structure in the blockchain: the transaction log. It is worth noticing that Smart Contracts cannot access the log and its event data.
    
    If we define a parameter as `indexed`, instead of being added to the data part of the log, it is added to a special data structure called **topics** instead of the data part of the log. A topic can only hold a single word of 32 bytes, so if we use a **reference type**, only its hash is stored (using keccak-256). Each event can **only** hold a maximum of 3 `indexed` parameters.
    
    Topics are what lets us search for events in the blockchain logs. We can filter them by a specific event, the contract address that emitted them,  and any indexed parameters defined in the event.

</SideDrawer>

<SideDrawer buttonText="Checkpoint Questions" title="All about Events">
  <Question question="lesson-1/events-Q1" />
  <Question question="lesson-1/events-Q2" />
  <Question question="lesson-1/events-Q3" />
  {/* <Question question="events-Q4" />  */}
</SideDrawer>
<br />

Go touch some grass ‚åõüòä

## Compile & Deploy

Now that we have written our smart contract in full, we can compile it and
deploy it to a blockchain. Since we are using the Remix IDE, we can use its
tools in the sidebar for this. Here‚Äôs a brief description of the tools icons:

![Remix Menu](/assets/lessons/1/img_3.png)

- At the top, the logo links us to the Home (and help links) of Remix
- Then, we have our File Explorer
- The magnifying glass icon is for searching in files
- Highlighted in red, the Solidity Compiler (our next step)
- Highlighted in green, Deploy & Run transactions

To compile our smart contract we should click on the **Solidity Compiler** icon
in the sidebar.

Leave all the settings in their default, manually select our contract in the
drop down menu and click on the **Compile WAGMI.sol** button.

![Remix Contract Compiler Button](/assets/lessons/1/img_4.png)

![Remix Successful Compilation Indicator](/assets/lessons/1/img_5.png)

After compiling, we should see a green check mark on top of the Solidity
Compiler sidebar icon.

<SideDrawer buttonText="Problems at Compile Time?">
    
    First, check that you have selected a compiler compatible with our version (0.8.4 or any higher inside the 0.8 version).
    
    If you still have any problems when compiling, you can compare your code to my final code. Mine looks like this (with most comments removed for readability):
    
    ```solidity
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.4;
    
    contract WAGMI {
    
        // State Variables
        string message;
        uint256 messageCount;
    
        // Events
        event Web3Future(uint256 indexed messageIndex, address indexed author, string message, string future);
    
        // Functions
        function getMessage() public view returns(string memory) {
            return message;
        }
    
        function getMessageCount() public view returns(uint256) {
            return messageCount;
        }
    
        function setMessage(string calldata newMessage) public {
            messageCount++;
            message = newMessage;
    
            string memory future = 'NGMI';
            if (keccak256(abi.encodePacked(newMessage)) == keccak256(abi.encodePacked('gm'))) {
                future = 'WAGMI';
            }
    
            emit Web3Future(messageCount, msg.sender, newMessage, future);
        }
    
    }
    ```

</SideDrawer>

Now we are ready to deploy our contract. We can now head to the **Deploy & Run**
transactions icon in the sidebar. Below we can see a message that says
‚ÄòCurrently you have no contract instances to interact with‚Äô, so we haven‚Äôt
deployed anything yet.

![Contract Instance Warning](/assets/lessons/1/img_6.png)

Again, we are leaving all options to default for now. We‚Äôll be learning how to
deploy to a testnet later on. Click on the **Deploy** button!

Once deployment finishes, we are going to see our shiny new deployed contract
instance below.

Open the dropdown under **Deployed Contracts**, to see our function tabs:

- the blue ones are our **view** functions that don‚Äôt modify our state
- the orange one lets us trigger the setMessage function which will change the
  state. Be sure to click on the little drop down menu on the right. From here
  on, we can interact with our contract. Feel free to test the functions. Click
  on the getMessage and messageCount tabs before and after setting a new message
  to modify data on our contract.

![Available Interactive Options once Contract is Deployed](/assets/lessons/1/img_7.png)

From here on, we can interact with our contract. Feel free to test the
functions. Click on the getMessage and messageCount tabs before and after
setting a new message.

On the right hand side, below our contract code, there‚Äôs a bar on the bottom. If
it hasn‚Äôt opened automatically, we can open the console from here to see any
transactions with the green check mark. The first transaction is the deployment
of our contract. Click it to open it.

![Button to Minimise and Maximise Console](/assets/lessons/1/img_8.png)

Once you set a new message, you‚Äôll see again, that the transaction has a green
check mark, open it and look for the **logs**. Here‚Äôs my info after setting the
message to ‚ÄúMy first smart contract‚Äù:

![Complete Transaction Log of Deployed Contract](/assets/lessons/1/img_9.png)

If you look closely, inside the **logs** part, our smart contract predicted a
'future' for us.

What if you try out setting the message to `gm` and look at the logs again. Can
you see the magical spell that is being cast here?

<br />
<p align="center">
  <img
    src="/assets/lessons/1/img_11.png"
    width="300"
    alt="Genie Girl holds Ethereum Crystal Ball"
  />
</p>

Before you go ahead and tell us **what your future in web3 is**, have a check on
what you didn‚Äôt know a little while ago, and what you know now!

<br />
<br />
<QuizStatusChecker quiz="quiz-lesson-1" />
<br />
<br />

Now, go to the community in
[developerdao.peeranha.io](https://developerdao.peeranha.io) to share your new
Open Sourcerer powers! And afterwards get started on our _Build a basic NFT_
lesson. See you soon!

import { ContributorFooter } from "../../../components/mdx/ContributorFooter";

<ContributorFooter
  authors={["_7i7o", "piablo"]}
  reviewers={["georgemac510", "wolovim"]}
  contributors={["mveve"]}
/>
</Layout>
